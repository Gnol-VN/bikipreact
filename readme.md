# 1. Component  
The primary unit of React is Component. It is like a function whose Input: props, state, Output: UI.  
But, you don't invoke Component like function, you just use it in HTML, for examples <Component />  
Component can manage a private state which is changable data over the lifecycle of the component.

Why does it name "React". React will react to the change in a component state, which means re-rendering the UI.

The HTML is generated by React. So by using react, you don't write HTML template files. 

* **Props input** is **explicit, unchangable**. It is similar to the list of attributes that HTML element can have.  
* **State input** is **internal, changable**. It is the inner data of a component, which makes components stateful.

To display a component in browser, we need to use ReactDom.render(arg1, arg2) function.
* arg1: the root component - entry point
* arg2: the DOM element in browser where root component shows

```
const Hello = () => {
    return <div> Hello react </div>; // this is not HTML, this is JSX. JSX gets compiled by Babel into old ES5 that browser can render 
}

Using Babel, return <div> Hello react </div> will be 
    return React.createElement('div', null, 'Hello react');
```

# 2. State
useState() function is a HOOK, which means it hooks a stateful state into a component.   
useState() returns a tuple of Getter and Setter.
Inside HTML code, we can execute Javascript in curly bracket {}
```
const Button = () => {
    const [counter, setCounter] = useState(0);
    return <button onClick={FUNCTION_REFERENCE}{counter}</button>
}
```
The FUNCTION_REFERENCE above can be:
* a function name, which is declared somewhere, ex: onClick={printRandomNumber} - without round brackets
* arrow function,  ex: onClick={() => console.log(Math.random())}

The FUNCTION_REFERENCE above is a reference (pointer) to a function, it does **not** invoke the function, so

# 3. Props
In short, props is used when a parent component want to pass something to other components. Something here can be a state (counter),or any functions. 


If you are in Component_B and want to change **state1** of Component_C, then you can't do it directly like ~~Component_C.state1 = 3~~.
To do that, **state1** must be in a parent Component_A, and Component_A contains Component_B and Component_C.  

This example shows App component pass counter value to Display component to display; pass inc function to Button component through props.  
Note, if you want to use props in a component, you must declare **props** in component function signature
```
const App = () => {
  const [counter, setCounter] = useState(1);
  const inc = () => {
    setCounter(counter+1);
  }
  return (
    <>
      <Button  onClickHandler={inc}/>
      <Display  number={counter}/>
    </>
  )
}

const Button = (props) => {
	return <button onClick={props.onClickHandler}>+1</button>
}

const Display = (props) => {
  return <div>{props.number}</div>
}


ReactDOM.render(
  <App />,
  document.getElementById('mountNode'),
);
```

# Other
## <>
render() function only takes 1 element, not 2 elements in the same level. For example:
```
ReactDOM.render(
    <button />
    <button /> // not two same level div
)
```
What we can do is to have a wrapper div
```
<div>
    <button/>
    <button/>
</div>
```
But, it will create an empty div which is redundant after rendering in HTML. To get rid of this redundant div, we use:
```
<> // which is a shortcut for <React.Fragment> </React.Fragment>
    <button/>
    <button/>
</>
```