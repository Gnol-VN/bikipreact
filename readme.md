# 1. Component  
The primary unit of React is Component. It is like a function whose Input: props, state, Output: UI.  
But, you don't invoke Component like function, you just use it in HTML, for examples `<Component />`  
Component can manage a private state which is changable data over the lifecycle of the component.

Why does it name "React". React will react to the change in a component state, which means re-rendering the UI.

The HTML is generated by React. So by using react, you don't write HTML template files. 

* **Props input** is **explicit, unchangable**. It is similar to the list of attributes that HTML element can have.  
* **State input** is **internal, changable**. It is the inner data of a component, which makes components stateful.

To display a component in browser, we need to use `ReactDom.render(arg1, arg2)` function.
* arg1: the root component - entry point
* arg2: the DOM element in browser where root component shows

```
// Component Hello
const Hello = () => {
    return <div> Hello react </div>; // this is not HTML, this is JSX. JSX gets compiled by Babel into old ES5 that browser can render 
}

Using Babel, return <div> Hello react </div> will be 
    return React.createElement('div', null, 'Hello react');
```

# 2. State
useState() function is a HOOK, which means it hooks a stateful state into a component.   
useState() returns a tuple of Getter and Setter.
Inside HTML code, we can execute Javascript in curly bracket {}
```
const Button = () => {
    const [counter, setCounter] = useState(initialValue);
    return <button onClick={FUNCTION_REFERENCE}{counter}</button>
}
```
The FUNCTION_REFERENCE above can be:
* a function name, which is declared somewhere, ex: onClick={printRandomNumber} - without round brackets
* arrow function,  ex: onClick={() => console.log(Math.random())}

The FUNCTION_REFERENCE above is a reference (pointer) to a function, it does **not** invoke the function, so

# 3. Props
In short, props is used when a parent component want to pass something to other components. Something here can be a parent's state (counter),or any parent's functions (which can manipulate parent's state as well). 


If you are in Component_B and want to change **state1** of Component_C, then you can't do it directly like ~~Component_C.state1 = 3~~.
To do that, **state1** must be in a parent Component_A, and Component_A contains Component_B and Component_C.  

This example shows App component pass `counter value (state)` to Display component to display; pass `inc function` to Button component through props.  
Note, if you want to use props in a component, you must declare **props** in component function signature
```
const App = () => {
  const [counter, setCounter] = useState(1);
  const inc = () => {
    setCounter(counter+1);
  }
  return (
    <>
      <Button  onClickHandler={inc}/>
      <Display  number={counter}/>
    </>
  )
}

const Button = (props) => {
	return <button onClick={props.onClickHandler}>+1</button>
}

const Display = (props) => {
  return <div>{props.number}</div>
}


ReactDOM.render(
  <App />,
  document.getElementById('mountNode'),
);
```

# 4. Class component
If you use Class Component, props and state are accessible by `this.props` and `this.state`.
In class component, The state is defined in constructor method. **this.state must be an object**
Class component must have a `render()` function to render the DOM

```
class App extends React.Component {  
    constructor(props){
        super(props); // A Must
        this.state = {
            Key: Value
        }
    }
    render() {
        return <div>{{this.props.myProp1}}</div>
    }
}
```

# Other
### 1. <>
render() function only takes 1 element, not 2 elements in the same level. For example:
```
ReactDOM.render(
    <button />
    <button /> // not two same level div
)
```
What we can do is to have a wrapper div
```
<div>
    <button/>
    <button/>
</div>
```
But, it will create an empty div which is redundant after rendering in HTML. To get rid of this redundant div, we use:
```
<> // which is a shortcut for <React.Fragment> </React.Fragment>
    <button/>
    <button/>
</>
```
### 2. customProp={...} vs customProp="..."
* Use `{...}` to pass number/object 
* Only use `"..."` to pass string

### 3. `this` keyword in arrow function
In regular functions, `this` keyword represented the object that called the function, which could be the window, the document, a button or whatever.

With arrow functions, `this` keyword always represents the object which **defined** the arrow function.

### 4. `.then(CALL_BACK function(response))` to consume a `promise`

### 5. style={{}}
The first bracket is a dynamic JSX expression syntax.  
The second bracket is the object literal.

Besides, since style is an object, it can contain conditional styling, for example:  
` <div style={{color: Math.Rrandom() < 0.5 ? 'green' : 'red'}}></div>`

### 6. Spread syntax
```
const testData = [
    {name: "Long", id: 1},
    {name: "Do", id: 2}
]

<Card {...testData[0]} />
<Card {...testData[1]} />
```

Using spread syntax, all elements of testData will be `props` of Card component 